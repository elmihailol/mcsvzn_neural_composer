import operator
from heapq import nlargest
import numpy
from keras import Sequential
from keras.layers import LSTM, Dense
from music21 import converter, instrument, note, chord, stream
from music21.ext import joblib
import music21


def create_midi(prediction_output):
    """ convert the output from the prediction to notes and create a midi file
        from the notes """
    offset_plus = 0
    output_notes = []
    offset = 0
    # Уменьшаем количество одновременно играющих нот
    zero_counter = 0
    # create note and chord objects based on the values generated by the model
    for pattern in prediction_output:
        # pattern is a chord
        s = pattern.split("|")
        pattern = s[0]
        octave = s[2]
        try:
            offset += float(s[1])
            if float(s[1]) == 0:
                zero_counter += 1
            else:
                zero_counter = 0
            # offset = round(offset, 0)
        except:
            print("error", s[1])
            continue
        # if zero_counter > 2:
        #     continue
        # offset += 0.5
        # print(pattern,"/",offset)
        if ('.' in pattern) or pattern.isdigit():
            notes_in_chord = pattern.split('.')
            notes = []
            for current_note in notes_in_chord:
                new_note = note.Note(int(current_note))
                new_note.storedInstrument = instrument.PipeOrgan()
                new_note.volume.velocity = 60
                notes.append(new_note)
            new_chord = chord.Chord(notes)
            new_chord.offset = offset
            output_notes.append(new_chord)
        # pattern is a note
        else:
            new_note = note.Note(pattern)
            new_note.offset = offset
            new_note.volume.velocity = 60
            new_note.octave = octave
            new_note.storedInstrument = instrument.PipeOrgan()
            output_notes.append(new_note)

        # increase offset each iteration so that notes do not stack
        # offset += 0.5

    midi_stream = stream.Stream(output_notes)

    midi_stream.write('midi', fp='test_output.mid')


def get_msg(file):
    notes = []
    n = 0
    try:
        midi = converter.parse(file)
        print(file)
        notes_to_parse = None
        parts = instrument.partitionByInstrument(midi)
        if parts:  # file has instrument parts
            notes_to_parse = parts.parts[0].recurse()
        else:  # file has notes in a flat structure
            notes_to_parse = midi.flat.notes
        prev_offset = 0
        for element in notes_to_parse:
            # if n > 1000:
            #     break
            new_offset = 0.5
            # print(element.offset)
            if prev_offset == element.offset:
                new_offset = 0
            else:
                new_offset = element.offset - prev_offset
                # if 0 < new_offset <= 0.25:
                #     new_offset = 0.25
                if 0 < new_offset <= 0.5:
                    new_offset = 0.5
                if 0.5 < new_offset <= 1:
                    new_offset = 1

                if 1 < new_offset <= 1.5:
                    new_offset = 1.5
                if 1.5 < new_offset:
                    new_offset = 2
            # print(n, len(notes_to_parse))
            if isinstance(element, note.Note):
                # print(element.octave)
                notes.append(str(element.pitch) + "|" + str(new_offset) + "|" + str(element.octave))
                # print(notes[n])
                n += 1
            elif isinstance(element, chord.Chord):
                notes.append('.'.join(str(n) for n in element.normalOrder) + "|" + str(new_offset)
                             + "|")
                n += 1

            prev_offset = element.offset
    except Exception:
        print("Что - то не так")
    return notes
